.\"-------
.\" IS, IE -- sublist begin and end
.\"-------
.de IS
.ie \n(.g .RS
.el \{\
.nr )R +7m
.nr )P -.5v
.sp .7v \}
..
.de IE
.ie \n(.g .RE
.el \{\
.nr )R -7m
.nr )P +.5v
.sp .4v \}
..
.TH ES 1 "20 November 2025"
.SH NAME
es \- veety's extensible shell
.SH SYNOPSIS
.SY es
.OP \-sIAlNpodv
.OP \-X "extended argument"
.OP \-D "debugging flags"
.OP \-r "run flags"
.OP \-c command
.RI [ file
.RI [ args ... ] ]
.SH DESCRIPTION
.I Es
is a command interpreter and programming language which combines
the features of other Unix shells and the features of a functional
programming language such as Scheme.
The syntax is derived from
.IR rc (1).
.I Es
is intended for use both as an interactive shell and a programming
language for scripts.
.PP
.I Es
is an extremely customizable language.
The semantics can be altered radically by redefining functions that
are called to implement internal operations.
This manual page describes the default, initial configuration.
See the section entitled
.B "Hook Functions"
for details on entry points which can be redefined to give
the shell extended semantics.
.SH LANGUAGE
.I Es
is an interpreter which reads commands and executes them.
The simplest form of command in
.I es
is a sequence of words separated by white space (space and tab) characters.
A word is either a string or a program fragment (see below).
The first word is the command to be executed; the remaining
words are passed as arguments to that command.
If the first word is a string, it is a interpreted as the
name of a program or shell function to run.
If the name is the name of a shell function, that function
is executed.
Otherwise, the name is used as the name of an executable file.
If the name begins with \f(CW/\fP, \f(CW./\fP, or \f(CW../\fP,
then it is used as the absolute path name of a file;
if not,
.I es
looks for an executable file in the directories named by \f(CW$path.\fP
.PP
Commands are terminated by newline or semicolon (;).
A command may also be terminated by an ampersand (&),
which causes the command to be run in the background:
the shell does not wait for the command
to finish before continuing execution.
Background processes have an implicit redirection of \f(CW/dev/null\fP
as their standard input that may be overridden by an explicit redirection.
.SS Quoting
.IR Es
gives several characters special meaning;
special characters automatically terminate words.
The following characters, along with space, tab, and newline, are special:
.PP
.EX
# $ & \' ( ) ; < = > \e ^ \` { | }
.EE
.PP
The single quote (\f(CW\(aq\fP) prevents special treatment
of any character other than itself. Any characters between single
quotes, including newlines, backslashes, and control characters,
are treated as an uninterpreted string. A quote character itself
may be quoted by placing two quotes in a row. A single quote character
is therefore represented by the sequence \f(CW\(aq\(aq\(aq\(aq\fP and
the empty string is represented by \f(CW\(aq\(aq\fP.
.br
Thus:
.EX
echo 'What''s the plan, Stan?'
.EE
.PP
prints out
.EX
What's the plan, Stan?
.EE
.PP
The backslash (\f(CW\e\fP)
quotes the immediately following character, if it is
one of the special characters, except for newline.
In addition,
.IR es
recognizes backslash sequences similar to those used in C strings (plus some extras):
.IS
.TP
\f(CW\ea\fP
alert (bell)
.TP
\f(CW\eb\fP
backspace
.TP
\f(CW\ee\fP
escape
.TP
\f(CW\ef\fP
form-feed
.TP
\f(CW\en\fP
newline
.TP
\f(CW\er\fP
carriage return
.TP
\f(CW\et\fP
tab
.TP
\f(CW\eds\fP
editor formatting start
.TP
\f(CW\ede\fP
editor formatting end
.TP
\f(CW\ex\fP \fInn\fP
hexadecimal character
.IR nn
.TP
\f(CW\e\fInnn\fP
octal character
.IR nnn
.IE
.SS Comments
The number sign (\f(CW#\fP) begins a comment in
.IR es .
All characters up to but not including the next newline are ignored.
.SS "Line continuation"
A long logical line may be continued over several physical lines by
terminating each line (except the last) with a backslash (\f(CW\e\fP).
The backslash-newline sequence is treated as a space.
Note that line continuation does not work in comments, where the backslash is
treated as part of the comment, and inside quoted strings, where the backslash
and newline are quoted.
.SS Lists
The primary data structure in
.IR es
is the list, which is a sequence of words.
Parentheses are used to group lists.
The empty list is represented by \f(CW()\fP
Lists have no hierarchical structure;
a list inside another list is expanded so that the
outer list contains all the elements of the inner list.
Thus, the following are all equivalent:
.EX
one two three
(one two three)
((one) () ((two three)))
.EE
.PP
Note that the null string, \f(CW''\fP,
and the empty list, \f(CW()\fP,
are two very
different things.
Assigning the null string to variable is a valid
operation, but it does not remove its definition.
.SS Concatenation
Two lists may be joined by the concatenation operator (\f(CW^\fP).
A single word is a list of length one, so
.EX
echo foo^bar
.EE
.PP
produces the output
.EX
foobar
.EE
.PP
For lists of more than one element,
concatenation produces the cross (Cartesian) product of
the elements in both lists:
.EX
echo (a\- b\- c\-)^(1 2)
.EE
.PP
produces the output
.EX
a\-1 a\-2 b\-1 b\-2 c\-1 c\-2
.EE
.SS "Variables"
A list may be assigned to a variable, using the notation:
.EX
\fIvar\f(CW = \fIlist\f(CW
.EE
.PP
Any sequence of non-special characters, except a sequence including
only digits, may be used as a variable name.
.I Es
exports all user-defined variables into the environment unless
it is explicitly told not to.
.PP
The value of a variable is referenced with the notation:
.EX
\f(CW$\fIvar\f(CW
.EE
.PP
Any variable which has not been assigned a value returns the empty list
when referenced.
In addition, multiple references are allowed:
.EX
a = foo
b = a
echo $$b
.EE
.PP
prints
.EX
foo
.EE
.PP
A variable's definition may also be removed by
assigning the empty list to a variable:
.EX
\fIvar\f(CW =
.EE
.PP
Multiple variables may be assigned with a single assignment statement.
The left hand side of the assignment operation consists of a list of
variables which are assigned, one by one, to the values in the list
on the right hand side.  If there are more variables than values in
the list, the empty list is assigned to the remaining variables.
If there are fewer variables than elements in the list, the last
variable is bound to all the remaining list values.
.PP
For example,
.EX
(a b) = 1 2 3
.EE
.PP
has the same effect as
.EX
a = 1
b = 2 3
.EE
.PP
and
.EX
(a b c) = 1 2
.EE
.PP
is the same as
.EX
a = 1
b = 2
c =
.EE
.PP
Also there is the ignore variable \f(CW$_\fP that can be used anywhere normal variables
can be used. Any assignment to it is thrown out.
.EX
(a _ c) = 1 2 3
.EE
.PP
is the same as
.EX
a = 1
c = 3
.EE
.PP
Note that when assigning values to more than one variable,
the list of variables must be enclosed in parentheses.
.PP
For \(lqfree careting\(rq (see below) to work correctly,
.I es
must make certain assumptions
about what characters may appear in a variable name.
.I Es
assumes that a variable name consists only of alphanumeric characters,
percent (\f(CW%\fP),
star (\f(CW*\fP),
dash (\f(CW-\fP),
and underscore (\f(CW\|_\|\fP).
To reference a variable with other
characters in its name, quote the variable name.
Thus:
.EX
echo $'we$Ird\Variab!le'
.EE
.PP
A variable name produced by some complex operation,
such as concatenation, should be enclosed in parentheses:
.EX
$(\fIvar\f(CW)
.EE
.PP
Thus:
.EX
Good\-Morning = Bonjour
Guten = Good
Morgen = Morning
echo $($Guten^\-^$Morgen)
.EE
.PP
prints
.EX
Bonjour
.EE
.PP
Each element of the list in parentheses is treated as an
independent variable and expanded separately.
Thus, given the above definitions,
.EX
echo $(Guten Morgen)
.EE
.PP
prints
.EX
Good Morning
.EE
.PP
To count the number of elements in a variable, use
.EX
$#\fIvar\f(CW
.EE
.PP
This returns a single-element list with the number of elements in
\f(CW$\fIvar\fP.
.SS Subscripting
Variables may be indexed with the notation
.EX
\f(CW$\fIvar\f(CW(\fIn\f(CW)
.EE
.PP
where
.I n
is a list of integers or ranges.
Subscript indexes are based at one.
The list of subscripts need
not be in order or even unique.
Thus, if
.EX
a = one two three
.EE
.PP
then
.EX
echo $a(3 3 3)
.EE
.PP
prints
.EX
three three three
.EE
.PP
Subscript indices which refer to nonexistent elements
expand to the empty list.  Thus, given the definition above
.EX
echo $a(3 1 4 1 5 9 2 6 5)
.EE
.PP
prints
.EX
three one one two
.EE
.PP
Subscript ranges are of the form
\fIlo\f(CW ... \fIhi\fP
and refer to all the elements between
\fIlo\fP and \fIhi\fP.
If
.I lo
is omitted, then \f(CW1\fP
is used as a default value; if
.I hi
is omitted, the length of the list is used.
Thus
.EX
* = $*(2 ...)
.EE
.PP
removes the first element of \f(CW*\fP,
similar to the effect of \f(CWshift\fP
in
.MR rc 1
or
.MR sh 1 .
.PP
The notation \f(CW$\fIn\fR, where
.I n
is an integer, is a shorthand for
\f(CW$*(\fIn\f(CW)\fP.
Thus,
.IR es 's
arguments may be referred to as
\f(CW$1\fP, \f(CW$2\fP, and so on.
.PP
Note that the list of subscripts may be given by any
.I es
expression, so
.EX
$var(\`{awk 'BEGIN{for(i=1;i<=10;i++)print i;exit }'})
.EE
.PP
returns the first 10 elements of
.Cr $var .
.SS "Free Carets"
.I Es
inserts carets (concatenation operators) for free in certain situations,
in order to save some typing on the user's behalf.
For example, the following are all equivalent:
.EX
cc \-O \-g \-c malloc.c alloca.c
cc \-^(O g c) (malloc alloca)^.c
opts=O g c; files=malloc alloca; cc \-$opts $files.c
.EE
.PP
.I Es
inserts a free-caret between the \(lq\f(CW\-\fP\(rq and \f(CW$opts\fP,
as well as between \f(CW$files\fP and \f(CW.c\fP.
The rule for free carets is as follows:
if a word or keyword is immediately
followed by another word, keyword, dollar-sign or
backquote without any intervening spaces, then
.I es
inserts a caret between them.
.SS "Flattened Lists"
To create a single-element list from a multi-element list,
with the components space-separated, use
.EX
$^\fIvar\f(CW
.EE
.PP
You can also flatten lists without space separating (useful if you want to generate a string) using
.EX
$"\fIvar\f(CW
.EE
.PP
Flattening is useful when the normal list concatenation rules need to be
bypassed.
For example, to append a single period at the end of \f(CW$path\fP,
use:
.EX
echo $^path.
.EE
.SS "String Lists"
String lists are lists produced by breaking a string into a list where each element
is one character. They can be useful for string manipulation tasks. They can be produced with
.EX
$:\fIvar
.EE
.SS "Wildcard Expansion"
.I Es
expands wildcards in filenames if possible.
When the characters \f(CW*\fP, \f(CW[\fP
or \f(CW?\fP
occur in an argument or command,
.I es
looks at the
argument as a pattern for matching against files.
(Contrary to the behavior some other shells exhibit,
.I es
will only perform pattern matching if a metacharacter occurs unquoted and
literally in the input.
Thus,
.EX
foo = '*'
echo $foo
.EE
.PP
will always echo just a star.
In order for non-literal metacharacters to be expanded, an
\f(CWeval\fP
statement must be used in order to rescan the input.)
Pattern matching occurs according to the following rules:
a \f(CW*\fP
matches any number (including zero) of
characters.
A \f(CW?\fP matches any single character, and a \f(CW[\fP
followed by a number of characters followed by a \f(CW]\fP
matches a single character in that
class.
The rules for character class matching are the same as those for
.MR ed 1 ,
with the exception that character class negation is achieved
with the tilde (\f(CW\(ti\fP), not the caret (\f(CW^\fP),
since the caret already means something else in
.IR es .
The filename component separator, slash (\f(CW/\fP),
must appear explicitly in patterns.
\f(CW*\fP and \f(CW?\fP do not match a dot character (\f(CW.\fP)
at the beginning of a filename component.
.PP
A tilde (\f(CW\(ti\fP)
as the first character of an argument is used to refer to home directories.
A tilde alone or followed by a slash (\f(CW/\fP)
is replaced by the value of \f(CW$home\fP,
which is usually the home directory of the current user.
A tilde followed by a username is replaced with the home directory
of that user, according to
.MR getpwent 3 .
.SS "Pattern Matching"
The tilde (\f(CW\(ti\fP) operator is used in
.I es
for matching strings against wildcard patterns.
The command
.EX
\(ti \fIsubject\fP \fIpattern\fP \fIpattern\fP ...
.EE
.PP
returns a true value if and only if the subject matches any of the patterns.
The matching follows the same rules as wildcard expansion, except that slashes
(\f(CW/\fP) are not considered significant, leading dots (\f(CW.\fP)
do not have to be matched explicitly, and home directory expansion does not occur.
Thus
.EX
\(ti foo f*
.EE
.PP
returns zero (true), while
.EX
\(ti (bar baz) f*
.EE
.PP
returns one (false).
The null list is matched by the null list, so
.EX
\(ti $foo ()
.EE
.PP
checks to see whether \f(CW$foo\fP is empty or not.
This may also be achieved by the test
.EX
\(ti $#foo 0
.EE
.PP
Note that inside a \f(CW\(ti\fP command
.I es
does not match patterns against file
names, so it is not necessary to quote the characters
\f(CW*\fP, \f(CW[\fP, and \f(CW?\fP. However,
.I es
does expand the subject against filenames if it contains
metacharacters.
Thus, the command
.EX
\(ti * ?
.EE
.PP
returns true if any of the files in the current directory have a
single-character name.
Note that if the \f(CW\(ti\fP
command is given a list as its first
argument, then a successful match against any of the elements of that
list will cause \f(CW\(ti\fP to return true.
For example:
.EX
\(ti (foo goo zoo) z*
.EE
.PP
is true.
.SS "Matching Multiple Patterns"
.I Es
provides a
.Cr match
command for cases where repeated pattern matching with the tilde (\f(CW\(ti\fP)
operator is inconvenient.
.PP
This invocation compares the
.I subject
against the given patterns and executes the first action corresponding
with a matched pattern, or throws an \f(CWerror\fP
exception if no matches for the
.I subject
exist:
.EX
match \fIsubject\fP (
    \fIpattern1\fP {\fIaction1\fP}
    (\fIpattern2 pattern3\fP) {\fIaction2\fP}
    * { echo 'no matching patterns' }
)
.EE
.PP
The body of a \f(CWmatch\fP must be wrapped in parentheses. Each
.I pattern
must be on the same line as its corresponding
.IR action ,
and separate
.IR pattern - action
pairs must be separated by newlines or semicolons.
.PP
The matching behavior is equivalent to an
\f(CWif\fP command with multiple \f(CW\(ti\fP
comparisons. For example, the \f(CWmatch\fP
command and the \f(CWif\fP command below are equivalent:
.EX
               bc = bang crack
               bp = biff plop
               bw = bam boom wham

match $sound (            if {\(ti $sound $bc} {
    $bc {result 3}            result 3
    ($bp $bw *ow) {}      } {\(ti $sound $bp $bw *ow} {
    * {                   } {
      false                   false
    }                     }
)
.EE
.PP
The value of the
.I subject
being matched is dynamically bound to the variable \f(CW$matchexpr\fP
within the body of the \f(CWmatch\fP.
.PP
Also available are \f(CWmatchall\fP and \f(CWprocess\fP.
\f(CWmatchall\fP will execute all actions that match and
will only execute the wildcard if there are no matches.
\f(CWprocess\fP is broadly equivalent to
.EX
for (l = $list) {
    match $l (
        pattern1 { action1 }
        * { wildaction }
    )
}
.EE
.SS "Pattern Extraction"
The double-tilde (\f(CW\(ti\(ti\fP) operator is used in
.I es
for extracting the parts of strings that match patterns.
The command
.EX
\(ti\(ti \fIsubject\fP \fIpattern\fP \fIpattern\fP ...
.EE
.PP
returns the parts of each matching subject which correspond to the
wildcards.
.PP
Each subject is checked in order against each pattern;  if it matches
the pattern, the parts of the subject which matched each \f(CW*\fP,
\f(CW?\fP, or \f(CW[]\fP character range are extracted, and processing
moves on to the next subject.  If the subject does not match, the next
pattern is tried.
.PP
For example, the result of the extraction operation
.EX
\(ti\(ti (foo.c foo.x bar.h) *.[ch]
.EE
.PP
is the list \f(CW(foo c bar h)\fP.
.SS "Regular Expressions"
Regular expressions are available to be used in matches and extractions as an
alternative to wildcards. See
.MR pcre2 3
for more information on regular expressions.
.EX
\(ti $maybe_number %re('^[0-9]+$')
\(ti $maybe_whitespace %re('^[ \et\er\en]+$')
.EE
.SS "Command Substitution"
A list may be formed from the output of a command by using backquote
substitution:
.EX
\`{ \fIcommand\fP }
.EE
.PP
returns a list formed from the standard output of the command in braces.
The characters stored in the variable \f(CW$ifs\fP (for \(lqinput field separator\(rq)
are used to split the output into list elements.
By default, \f(CW$ifs\fP has the value space-tab-newline.
The braces may be omitted if the command is a single word.
Thus \f(CW\`ls\fP may be used instead of \f(CW\`{ls}\fP.
This last feature is useful when defining functions that expand
to useful argument lists.
A frequent use is:
.EX
fn src { echo *.[chy] }
.EE
.PP
followed by
.EX
wc \`src
.EE
.PP
(This will print out a word-count of all C and Yacc source files in the current
directory.)
.PP
In order to override the value of \f(CW$ifs\fP for a single command substitution, use:
.EX
\`\` \fIifs-list\fP { \fIcommand\fP }
.EE
.PP
\f(CW$ifs\fP will be temporarily ignored and the command's output will be
split as specified by the list following the double backquote.
For example:
.EX
\`\` :\en {cat /etc/passwd}
.EE
.PP
splits up \f(CW/etc/passwd\fP into fields.
.SS "Return Values"
The return value of a command is obtained with the construct
.EX
<={ \fIcommand\fP }
.EE
.PP
The return value of an external program is its exit status
(which in other shells can be found in special variables such as
\f(CW$?\fP or \f(CW$status\fP ),
as either a small integer or the name of signal.
Thus
.EX
echo <={test \-f /etc/motd} <={test \-w /vmunix} <=a.out
.EE
.PP
might produce the output
.EX
0 1 sigsegv+core
.EE
.PP
along with any output or error messages from the programs.
.PP
.I Es
functions and primitives can produce \(lqrich return values,\(rq
that is, arbitrary lists as return values.
.PP
When return values are interpreted as truth values,
an extension of the normal shell conventions apply.
If any element of a list is not equal to \(lq\f(CW0\fP\(rq
(or the empty string), that list is considered false.
.PP
The return value of an assignment operation is the assigned value.
.SS "Logical Operators"
There are a number of operators in
.I es
which depend on the exit status of a command.
.EX
\fIcommand1\fP && \fIcommand2\fP
.EE
.PP
executes the first command and then executes the second command if and only if
the first command has a \(lqtrue\(rq return value.
.EX
\fIcommand1\fP || \fIcommand2\fP
.EE
.PP
executes the first command and then executes the second command if and only if
the first command has a \(lqfalse\(rq return value.
.EX
! \fIcommand\fP
.EE
.PP
inverts the truth value of the exit status of a command.
.SS "Input and output"
.PP
The standard output of a command may be redirected to a file with
.EX
command > file
.EE
.PP
and the standard input may be taken from a file with
.EX
command < file
.EE
.PP
File descriptors other than 0 and 1 may be specified also.
For example, to redirect standard error to a file, use:
.EX
command >[2] file
.EE
.PP
In order to duplicate a file descriptor, use
\f(CW>[\fIn\f(CW=\fIm\f(CW]\fP.
Thus to redirect both standard output and standard error
to the same file, use
.EX
command > file >[2=1]
.EE
.PP
To close a file descriptor that may be open, use
\f(CW>[\fIn\f(CW=]\fP. For example, to close file descriptor 7:
.EX
command >[7=]
.EE
.PP
In order to place the output of a command at the end of an already
existing file, use:
.EX
command >> file
.EE
.PP
If the file does not exist, then it is created.
.PP
To open a file for reading and writing, use the
\f(CW<>\fP redirection operator; for reading and appending, use \f(CW<>>\fP.
Both of these operators use file descriptor 0 (standard input)
by default. Similarly, \f(CW><\fP truncates a file and opens
it for reading and writing, and \f(CW>><\fP opens a file for reading and appending;
these operators use file descriptor 1 by default.
.PP
\(lqHere documents\(rq are supported as in
.MR sh 1
with the use of
.EX
command << 'eof-marker'
.EE
.PP
If the end-of-file marker is quoted,
then no variable substitution occurs inside the here document.
Otherwise, every variable is substituted
by its space-separated-list value (see
.BR "Flat Lists" ,
below),
and if a \f(CW^\fP character follows a variable name, it is deleted.
This allows the unambiguous use of variables adjacent to text, as in
.EX
$variable^follow
.EE
.PP
To include a literal \f(CW$\fP in a here document created with an
unquoted end-of-file marker, use \f(CW$$\fP.
.PP
Additionally,
.I es
supports \(lqhere strings\(rq, which are like here documents,
except that input is taken directly from a string on the command line.
Its use is illustrated here:
.EX
cat <<< 'this is a here string' | wc
.EE
.PP
(This feature enables
.I es
to export functions that use here documents.)
.SS Pipes
Two or more commands may be combined in a pipeline by placing the
vertical bar (\f(CW\||\|\fP) between them. The standard output (file descriptor 1)
of the command on the left is tied to the standard input (file
descriptor 0) of the command on the right.
The notation \f(CW|[\fIn\f(CW=\fIm\f(CW]\fP indicates that file descriptor
.I n
of the left process is connected to file descriptor
.I m
of the right process. \f(CW|[\fIn\f(CW]\fP is a shorthand for
\f(CW|[\fIn\f(CW=0]\fP. As an example, to pipe the standard error of a command to
.MR wc 1 ,
use:
.EX
command |[2] wc
.EE
.PP
The exit status of a pipeline is considered true if and only if every
command in the pipeline exits true.
.SS "Function Pipes"
Functions pipes appends the return value of the first function to the end of the
next functions argument list. Therefore
.EX
fna |> fnb 1 2 |> fnc 3 4
.EE
.PP
will expand into
.EX
fnc 3 4 <={fnb 1 2 <={fna}}
.EE
.SS "Input/Output Substitution"
Some commands, like
.MR cmp 1
or
.MR diff 1,
take their input from named files on the command
line, and do not use standard input.
It is convenient sometimes to build nonlinear
pipelines so that a command like
.I cmp
can read the output of two commands at once.
.I Es
does it like this:
.EX
cmp <{command1} <{command2}
.EE
.PP
compares the output of the two commands.
Note: on some systems, this form of
redirection is implemented with pipes, and since one cannot
.MR lseek 2
on a pipe, commands that use
.MR lseek 2
will hang.
For example,
most versions of
.I diff
seek on their inputs.
.PP
Data can be sent down a pipe to several commands using
.MR tee 1
and the output version of this notation:
.EX
echo hi there | tee >{sed 's/^/p1 /'} >{sed 's/^/p2 /'}
.EE
.SS "Program Fragments"
.I Es
allows the intermixing of code with strings.
A program fragment, which is a group of commands enclosed in
braces (\f(CW{\fP and \f(CW}\fP), may be used anywhere a word
is expected, and is treated as an indivisible unit.
For example, a program fragment may be passed as an argument,
stored in a variable,
or written to a file or pipe.
If a program fragment appears as the first word in a command,
it is executed, and any arguments are ignored.
Thus the following all produce the same output:
.EX
{ echo hello, world }
{ echo hello, world } foo bar
es -c { echo hello, world }
x = { echo hello, world }; $x
echo { echo hello, world } | es
echo { echo hello, world } > foo; es < foo
.EE
.PP
Since program fragments in the first position in a command are executed,
braces may be used as a grouping mechanism for commands.
For example, to run several commands, with output from all of them redirected to
the same file, one can do
.EX
{ date; ps agux; who } > snapshot
.EE
.PP
In addition, program fragments can continue across multiple physical lines
without explicit line continuations, so the above command could also be written:
.EX
{
    date
    ps agux
    who
} > snapshot
.EE
.PP
A
.I lambda
is a variant on a program fragment which takes arguments.
A lambda has the form
.EX
@ \fIparameters\fP { \fIcommands\fP }
.EE
.PP
The
.I parameters
are one or more variable names (including \f(CW_\fP), to which arguments of the
lambda are assigned while the
.I commands
are run.
The first argument is assigned to the first variable,
the second to the second, and so on.
If there are more arguments than parameters,
the last named variable is assigned all the remaining arguments;
if there are fewer, the parameters for which there are no arguments
are bound to the empty list.
If no parameters are listed, the variable named \f(CW*\fP
is assigned all the arguments of the lambda.
Note that \f(CW@\fP is a keyword and not a special character
in \fIes\fP, so it must be separated by whitespace from other words.
.PP
As a small example,
.EX
@ { echo $* } hi
.EE
.PP
is a complicated way of producing the output \f(CWhi\fP.
The first word is a function which echoes its
arguments, and the second word is the argument to the function, the
word \f(CWhi\fP.
.PP
Lambdas, like other program fragments, can appear anywhere in a list.
A more complicated example in the same spirit:
.EX
@ cmd arg { $cmd $arg } @ { echo $* } hi
.EE
.PP
This command executes a lambda which runs its first argument, named
\f(CWcmd\fP, using its second argument, named \f(CWarg\fP,
as the argument for the first.
The first argument of this function is another lambda,
seen previously, and the second argument is the word \f(CWhi\fP.
.PP
These lambda expressions
.EX
@ a b c { echo $c $b $a } 1 2
@ a b c { echo $c $b $a } 1 2 3 4 5
@ a b c _ { echo $c $b $a } 1 2 3 4 5
.EE
.PP
produce this output:
.EX
2 1
3 4 5 2 1
3 2 1
.EE
.SS Functions
A function in
.I es
is introduced with the syntax
.EX
fn \fIname\fP \fIparameters\fP { \fIcommands\fP }
.EE
.PP
If the function name appears as the first word of a command,
the commands are run, with the named parameters bound to the
arguments to the function.
.PP
The similarity between functions and lambdas is not coincidental.
A function in
.I es
is a variable of the form \f(CWfn\-\fP\fIname\fP.
If name for which the appropriate \f(CWfn-\fP
variable exists is found in the first position of a command,
the value of the variable is substituted for the first word.
The above syntax for creating functions is equivalent to the
variable assignment
.EX
fn\-\fIname\fP = @ \fIparameters\fP { \fIcommands\fP }
.EE
.PP
Functions may be deleted with the syntax
.EX
fn \fIname\fP
.EE
.PP
which is equivalent to the assignment
.EX
fn\-\fIname\fP =
.EE
.PP
If, as the most common case, a function variable is bound to a lambda,
when the function is invoked, the variable \f(CW$0\fP
is bound (dynamically, see below) to the name of the function.
.PP
Lambdas are just another form of code fragment, and, as such, can be
exported in the environment, passed as arguments, etc.
The central difference between the two forms is that lambdas bind their arguments,
while simple brace-enclosed groups just ignore theirs.
.SS "Dynamically Scoped Variables"
Dynamically scoped variable assignments may be made with the \f(CWlocal\fP construct:
.EX
local (\fIvar\fP = \fIvalue\fP; \fIvar\fP = \fIvalue ...\fP) \fIcommand\fP
.EE
.PP
The command may be a program fragment, so for example:
.EX
local (path = /bin /usr/bin; ifs = ) {
    \fI...\fP
}
.EE
.PP
sets \f(CW$path\fP to a minimal useful path and removes \f(CW$ifs\fP
for the duration of one long compound command.
.PP
Local-bound variables are exported into the environment,
and will invoke appropriately named settor and gettor functions (see below).
.SS "Lexically Scoped Variables"
In addition to local variables,
.I es
supports a different form of temporary variable binding,
using let-bound, or \(lqlexically scoped,\(rq variables.
(Lexical scoping is the form of binding used by most compiled
programming languages, such as C or Scheme.)
A lexically scoped variable is introduced with a \f(CWlet\fP statement:
.EX
let (\fIvar\fP = \fIvalue\fP; \fIvar\fP = \fIvalue ...\fP) \fIcommand\fP
.EE
.PP
All references to any of the variables defined in a \f(CWlet\fP
statement by any code located lexically (that is, textually) within the
.I command
portion of the statement will refer to the let-bound variable rather than
any environment or local-bound variable;
the immediate text of the \f(CWlet\fP
statement is the complete extent of that binding.
That is, lexically bound variables surrounding code fragments
follow those code fragments around.
.PP
An example best shows the difference between \f(CWlet\fP
and \f(CWlocal\fP (also known as \(lqdynamic\(rq) binding: (note that
\(lq\f(CW; \fP\(rq is \fIes\fP's default prompt.)
.EX
; x = foo
; let (x = bar) {
    echo $x
    fn lexical { echo $x }
}
bar
; local (x = baz) {
    echo $x
    fn dynamic { echo $x }
}
baz
; lexical
bar
; dynamic
foo
; 
.EE
.PP
Lexically bound variables are not exported into the environment,
and never cause the invocation of settor functions.
Function (lambda) parameters are lexically bound to their values.
.SS "For loops"
The command
.EX
for (\fIvar\fP = \fIlist\fP) \fIcommand\fP
.EE
.PP
Runs the
.I command
once for each element of the \fIlist\fP,
with the named variable bound lexically to each
element of the list, in order.
.PP
If multiple bindings are given in the \f(CWfor\fP
statement, the looping occurs in parallel and
stops when all lists are exhausted.
When one list is finished before the others,
the corresponding variable is bound to the empty list
for the remaining iterations.
Thus the loop
.EX
for (i = a b c; j = x y) echo $#i $i $#j $j
.EE
.PP
produces the output
.EX
1 a 1 x
1 b 1 y
1 c 0
.EE
.SS "Settor Functions"
A settor function is a variable of the form
\f(CWset-\fIvar\fR,
which is typically bound to a lambda.
Whenever a value is assigned to the named variable,
the lambda is invoked with its arguments bound to the new value.
While the settor function is running,
the variable
\f(CW$0\fP
is bound to the name of the variable being assigned.
The result of the settor function is used as the actual value in
the assignment.
.PP
For example, the following settor function is used to keep
the shell variables \f(CW$home\fP and \f(CW$HOME\fP synchronized.
.EX
set-HOME = @ {
    local (set-home = )
        home = $*
    result $*
}
.EE
.PP
This settor function is called when any assignment is made to the variable
\f(CW$HOME\fP. It assigns the new value to the variable \f(CW$home\fP,
but disables any settor function for \f(CW$home\fP to prevent an infinite recursion.
Then it returns its argument unchanged for use in the actual assignment to
\f(CW$HOME\fP.
.PP
Settor functions do not apply to lexically bound variables.
.SS "Gettor Functions"
Gettors are the inverse of settors. They are invoked on retrieval when a
variable exists (ie contains something). This causes the variable to return
the gettor result as opposed to the actual value of the variable. Gettors will
get the contents of the variable as arguments. They can be created like:
.EX
get-var = @ args { result $args }
.EE
.PP
A number of special variables are defined in terms of gettors.
.SS Primitives
Primitives are internal
.I es
operations that cannot or should not (for reasons of performance) be
written in the interpreter's language.
The set of primitives makes up the run-time library for \fIes\fP.
.PP
Primitives can be used with the syntax
.EX
$&\fIname\fP
.EE
.PP
A primitive can be used anywhere a lambda is expected.
The list of primitives is returned as the result of running
the primitive \f(CW$&primitives\fP.
.PP
For details on specific primitives, see the section entitled
.B PRIMITIVES
below.
.SS Exceptions
Exceptions in
.I es
are used for many forms of non-structured control flow,
notably error reporting, signals, and flow of control
constructs such as \f(CWbreak\fP and \f(CWreturn\fP.
.PP
Exceptions are passed up the call chain to catching routines.
A catcher may decide to intercept an exception,
retry the code that caused the exception,
or pass the exception along.
There can only be one exception raised at any time.
.PP
Exceptions are represented by lists.
The first word of an exception is, by convention, the type of exception
being raised.
The following exceptions are known:
.TP
\f(CWassert \fIexpression\fR
.TQ
\f(CWassert \fIsource\fP \fIexpression\fR
Exception thrown by assert if the expression is false and unreachable if executed
.TP
\f(CWbreak \fIvalue\fR
Exit from a loop.
The return value of the loop is the argument to the exception.
.TP
\f(CWcontinue\fP
Raised by continue and caught by loops. Similar to C's continue
.TP
\f(CWeof\fP
Raised by \f(CW%parse\fP when the end of input is reached.
.TP
\f(CWerror \fIsource\fP \fImessage\fP\fR
A run-time error.
Almost all shell errors are reported with the
\f(CWerror\fP
exception.
The default interactive loop and the outermost level of the
interpreter catch this exception and print the message.
.I Source
is the name of the routine (typically a primitive) which
raised the error.
.TP
\f(CWretry\fP
When raised from a signal catcher,
causes the body of the
\f(CWcatch\fP
clause to be run again.
.TP
\f(CWreturn \fIvalue\fR
Causes the current function to exit, with
.I value
as the return value (exit status).
.TP
\f(CWsignal \fIsigname\fR
Raised when the shell itself receives a signal,
and the signal is listed in the variable
\f(CWsignals\fP.
.I Signame
is the name of the signal that was raised.
.TP
\f(CWusage \fIutility\fP \fImessage\fR
Raised when the built-in utilities get invalid command line options.
.PP
See the builtin commands \f(CWcatch\fP and \f(CWthrow\fP
for details on how to manipulate exceptions.
.SH "SPECIAL VARIABLES"
Several variables are known to
.I es
and are treated specially.
Redefining these variables can change interpreter semantics.
Note that only dynamically bound (top-level or \f(CWlocal\fP-bound)
variables are interpreted in this way;
the names of lexically bound variables are unimportant.
.TP
\f(CW*\fP
The argument list of \fIes\fP.
\f(CW$1\fP, \f(CW$2\fP, etc. are the same as \f(CW$*(1)\fP, \f(CW$*(2)\fP, etc.
.TP
\f(CW$0\fP
Holds the value of
\f(CWargv[0]\fP with which \fIes\fP was invoked. Additionally,
\f(CW$0\fP is set to the name of a function for the duration of
the execution of that function, and \f(CW$0\fP is also set to
the name of the file being interpreted for the duration of a
\f(CW.\fP command.
.TP
\f(CWapid\fP
The process ID of the last process started in the background.
.TP
\f(CWapids\fP
The process IDs of all unwaited background processes.
.TP
\f(CWditto\fP
Contains the last input line. !! in commands will be replaced by $ditto
.TP
\f(CWhistory\fP
The name of a file to which commands are appended as
.I es
reads them.
This facilitates the use of a stand-alone history program
(such as
.MR history 1 )
which parses the contents of the history file and presents them to
.I es
for reinterpretation. If \f(CWhistory\fP is not set, then
.I es
does not append commands to any file.
.TP
\f(CWhome\fP
The current user's home directory, used in tilde (\f(CW\(ti\fP)
expansion, as the default directory for the builtin \f(CWcd\fP
command, and as the directory in which
.I es
looks to find its fallback initialization file, \f(CW.esrc\fP.
Like \f(CWpath\fP and \f(CWPATH\fP,
\f(CWhome\fP and \f(CWHOME\fP are aliased to each other.
.TP
\f(CWifs\fP
The default input field separator, used for splitting up the output of
backquote commands for digestion as a list.
The initial value of \f(CWifs\fP is space-tab-newline.
.TP
\f(CWlibraries\fP
A list of directories where
.I es
will search for \f(CWinit.es\fP and \f(CWimport\fP will search for libraries and modules.
By default
.I es
sets it to \f(CW$XDG_CONFIG_HOME/es-mveety\fP or, if \f(CW$XDG_CONFIG_HOME\fP is not set,
to \f(CW$home/.config/es-mveety\fP. If that directory does not exist it will try \f(CW$home/eslib\fP
(if it exists) then finally set it to \f(CW()\fP (if not).
.TP
\f(CWnoexport\fP
A list of variables which
.I es
will not export.
All variables except for the ones on this list and lexically bound variables
are exported.
.TP
\f(CWpath\fP
This is a list of directories to search in for commands.
The empty string stands for the current directory.
Note also that an assignment to \f(CWpath\fP causes an
automatic assignment to \f(CWPATH\fP, and vice-versa. If neither
\f(CWpath\fP nor \f(CWPATH\fP are set at startup time,
\f(CWpath\fP assumes a default value suitable for your system.
This is typically \f(CW(/usr/ucb /usr/bin /bin '')\fP.
.TP
\f(CWpid\fP
The process ID of the currently running \fIes\fP.
.TP
\f(CWppid\fP
Parent process ID. \f(CWpid\fP in the main shell and the process ID of the subshell if in a subshell.
.TP
\f(CWprompt\fP
This variable holds the two prompts (in list form) that
.I es
prints.
\f(CW$prompt(1)\fP is printed before each command is read, and \f(CW$prompt(2)\fP
is printed when input is expected to continue on the next
line.  (See \f(CW%parse\fP for details.)
.I es
sets
\f(CW$prompt\fP to \f(CW('; ' '')\fP by default.
The reason for this is that it enables an
.I es
user to grab commands from previous lines using a mouse, and to present them to
.I es
for re-interpretation; the semicolon prompt is simply ignored by
.IR es .
The null \f(CW$prompt(2)\fP also has its justification:  an
.I es
script, when typed interactively, will not leave
\f(CW$prompt(2)\fP's on the screen,
and can therefore be grabbed by a mouse and placed
directly into a file for use as a shell script, without further editing
being necessary.
.TP
\f(CWsignals\fP
Contains a list of the signals which
.I es
traps. Any signal name which is added to this list causes that signal
to raise an
.I es
exception.
For example, to run some commands and make sure some cleanup routine
is called even if the user interrupts or disconnects during the script,
one can use the form:
.EX
local (signals = $signals sighup sigint) {
     catch @ e {
          cleanup
          throw $e
     } {
           ...
     }
}
.EE
.TP
\&
A signal name prefixed by a hyphen (\f(CW-\fP) causes that signal to be ignored by
.I es
and all of its child processes, unless one of them resets its handler.
A signal prefixed by a slash (\f(CW/\fP)
is ignored in the current shell, but retains default behavior in
child processes. In addition, the signals \f(CWsigint\fP and \f(CWsigwinch\fP
may be preceded by the prefix (\f(CW.\fP)
to indicate that normal shell interrupt processing
(i.e., the printing of an extra newline and window resizing) occurs.
By default
.I es
starts up with \f(CW(sighup .sigint /sigquit sigill sigtrap
sigabrt sigemt sigfpe sigkill sigbus sigsegv sigsys sigpipe sigalrm /sigterm
sigurg sigstop sigtstp sigcont sigchld /sigttin /sigttou sigio sigxcpu sigxfsz
sigvtalrm /sigprof .sigwinch siginfo sigusr1 sigusr2)\fP
in \f(CW$signals\fP ; other values will be on the list if the shell starts up with
some signals ignored.
.TP
\f(CW*_conf_*\fP
These variables are used by the shell for configuration. They can be managed using \f(CWconf\fP.
.IE
.PP
The values of \f(CWpath\fP and \f(CWhome\fP are derived from the environment
values of \f(CWPATH\fP and \f(CWHOME\fP if those values are present.
This is for compatibility with other Unix programs, such as
.MR sh 1 .
\f(CW$PATH\fP is assumed to be a colon-separated list.
.SH "SYNTACTIC SUGAR"
.I Es
internally rewrites much of the syntax presented thus far
in terms of calls to shell functions.
Most features of
.I es
that resemble traditional shell features are included in this category.
This rewriting occurs at parse time, as commands are recognized
by the interpreter.
The shell functions that are the results of rewriting are some
of the hook functions documented below.
.PP
The following tables list all of the major rewriting which
.I es
does, with the forms typically entered by the user on the left
and their internal form on the right.
There is no reason for the user to avoid using the right-hand side forms,
except that they are usually less convenient.
To see the internal form of a specific command,
a user can run
.I es
with the \f(CW\-rnx\fP option;
when invoked in this way, the shell prints the internal form of its commands
rather than executing them.
.ta 2.3i
.SS "Control Flow"
.EX
.ft \*(Cf
! \fIcmd\fP	%not {\fIcmd\fP}
\fIcmd\fP &	%background {\fIcmd\fP}
\fIcmd1\fP ; \fIcmd2\fP	%seq {\fIcmd1\fP} {\fIcmd2\fP}
\fIcmd1\fP && \fIcmd2\fP	%and {\fIcmd1\fP} {\fIcmd2\fP}
\fIcmd1\fP || \fIcmd2\fP	%or {\fIcmd1\fP} {\fIcmd2\fP}
fn \fIname\fP \fIargs\fP { \fIcmd\fP }	fn-^\fIname\fP = @ \fIargs\fP {\fIcmd\fP}
.ft R
.EE
.SS "Input/Output Commands"
.EX
.ft \*(Cf
\fIcmd\fP < \fIfile\fP	%open 0 \fIfile\fP {\fIcmd\fP}
\fIcmd\fP > \fIfile\fP	%create 1 \fIfile\fP {\fIcmd\fP}
\fIcmd\fP >[\fIn\fP] \fIfile\fP	%create \fIn\fP \fIfile\fP {\fIcmd\fP}
\fIcmd\fP >> \fIfile\fP	%append 1 \fIfile\fP {\fIcmd\fP}
\fIcmd\fP <> \fIfile\fP	%open-write 0 \fIfile\fP {\fIcmd\fP}
\fIcmd\fP <>> \fIfile\fP	%open-append 0 \fIfile\fP {\fIcmd\fP}
\fIcmd\fP >< \fIfile\fP	%open-create 1 \fIfile\fP {\fIcmd\fP}
\fIcmd\fP >>< \fIfile\fP	%open-append 1 \fIfile\fP {\fIcmd\fP}
\fIcmd\fP >[\fIn\fP=]	%close \fIn\fP {\fIcmd\fP}
\fIcmd\fP >[\fIm\fP=\fIn\fP]	%dup \fIm\fP \fIn\fP {\fIcmd\fP}
\fIcmd\fP << tag \fIinput\fP tag	%here 0 \fIinput\fP {\fIcmd\fP}
\fIcmd\fP <<< \fIstring\fP	%here 0 \fIstring\fP {\fIcmd\fP}
\fIcmd1\fP | \fIcmd2\fP	%pipe {\fIcmd1\fP} 1 0 {\fIcmd2\fP}
\fIcmd1\fP |[\fIm\fP=\fIn\fP] \fIcmd2\fP	%pipe {\fIcmd1\fP} \fIm\fP \fIn\fP {\fIcmd2\fP}
\fIcmd1\fP >{ \fIcmd2\fP }	%writeto \fIvar\fP {\fIcmd2\fP} {\fIcmd1\fP $\fIvar\fP}
\fIcmd1\fP <{ \fIcmd2\fP }	%readfrom \fIvar\fP {\fIcmd2\fP} {\fIcmd1\fP $\fIvar\fP}
.ft R
.EE
.SS "Expressions"
.EX
.ft \*(Cf
$#\fIvar\fP	<={%count $\fIvar\fP}
$^\fIvar\fP	<={%flatten ' ' $\fIvar\fP}
\`{\fIcmd args\fP}	<={%backquote <={%flatten '' $ifs} {\fIcmd args\fP}}
\`\`\fIifs\fP {\fIcmd args\fP}	<={%backquote <={%flatten '' \fIifs\fP} {\fIcmd args\fP}}
.ft R
.EE
.SH BUILTINS
Builtin commands are shell functions that exist at shell startup time.
Most builtins are indistinguishable from external commands,
except that they run in the context of the shell itself rather than
as a child process.
Many builtins are implemented with primitives (see above).
.PP
Some builtin functions have names that begin with a percent character (\f(CW%\fP).
These are commands with some special meaning to the shell, or are meant for use only by
users customizing the shell. (This distinction is somewhat fuzzy, and the
decisions about which functions have \f(CW%\fP-names are somewhat arbitrary.)
.PP
All builtins can be redefined and extended by the user.
.SS "Builtin Commands"
.TP
\f(CW. \fR[\fP-einvx\fR]\fP \fIfile\f(CW \fR[\fIargs ...\fR]\fR
Reads
.I file
as input to
.I es
and executes its contents.
The options are a subset of the invocation options for the shell (see below).
.TP
\f(CWaccess \fR[\fP-n \fIname\fP\fR]\fP \fR[\fP-1e\fR]\fP \fR[\fP-rwx\fR]\fP  \fR[\fP-fdcblsp\fR]\fP \fIpath ...\fP\fR
Tests if the named paths are accessible according to the options presented.
Normally, \f(CWaccess\fP returns zero (true) for files which are accessible and a
printable error message (which evaluates as false, according to shell rules)
for files which are not accessible.
If the \f(CW\-1\fP option is used, the name of the first file which the test
succeeds for is returned; if the test succeeds for no file, the empty list is returned.
However, if the \f(CW\-e\fP option was used, \f(CWaccess\fP raises an \f(CWerror\fP exception.
If the \f(CW\-n\fP option is used, the pathname arguments are treated as a list of
directories, and the \fIname\fP option argument is used as a file in those directories
(i.e., \f(CW\-n\fP is used for path searching).
.sp 1v
The default test is whether a file exists.
These options change the test:
.IS
.TP
\f(CW\-r\fP
Is the file readable (by the current user)?
.TP
\f(CW\-w\fP
Is the file writable?
.TP
\f(CW\-x\fP
Is the file executable?
.sp .7v
.TP
\f(CW\-f\fP
Is the file a plain file?
.TP
\f(CW\-d\fP
Is the file a directory?
.TP
\f(CW\-c\fP
Is the file a character device?
.TP
\f(CW\-b\fP
Is the file a block device?
.TP
\f(CW\-l\fP
Is the file a symbolic link?
.TP
\f(CW\-s\fP
Is the file a socket?
.TP
\f(CW\-p\fP
Is the file a named pipe (FIFO)?
.IE
.TP
\f(CWbreak \fIvalue\fR
Exits the current loop.
.I Value
is used as the return value for the loop command.
.TP
\f(CWcatch \fIcatcher body\fR
Runs \fIbody\fP. If it raises an exception, \fIcatcher\fP is
run and passed the exception as an argument.
.TP
\f(CWcd \fR[\fP\fIdirectory\fP\fR]\fR
Changes the current directory to
.IR directory .
With no argument, \f(CWcd\fP changes the
current directory to \f(CW$home\fP.
.TP
\f(CWecho \fR[\fP-n\fR]\fP \fR[\fP--\fR]\fP \fIargs ...\fR
Prints its arguments to standard output, terminated by a newline.
Arguments are separated by spaces.
If the first argument is
\f(CW\-n\fP
no final newline is printed.
If the first argument is \f(CW\-\|\-\fP
then all other arguments are echoed literally;
this is used for echoing a literal \f(CW\-n\fP.
.TP
\f(CWeval \fIlist\fR
Concatenates the elements of
.I list
with spaces and feeds the resulting string to
the interpreter for rescanning and execution.
.TP
\f(CWexec \fIcmd\fP\fR
Replaces
.I es
with the given command.
If the
\f(CWexec\fP
contains only redirections,
then these redirections apply to the current shell
and the shell does not exit.
For example,
.EX
\f(CWexec {>[2] err.out}\fP
.EE
.TP
\&
places further output to standard error in the file
\fIerr.out\fP. Unlike some other shells,
.I es
requires that redirections in an \f(CWexec\fP be
enclosed in a program fragment.
.TP
\f(CWexit \fR[\fP\fIstatus\fP\fR]\fP\fR
Causes the current shell to exit with the given exit \fIstatus\fP.
If no argument is given, zero (true) is used.
(This is different from other shells, that often use the status of
the last command executed.)
.TP
\f(CWfalse\fP
Always returns a false (non-zero) return value.
.TP
\f(CWforever \fIcmd\fR
Runs the command repeatedly, until the shell exits or the
command raises an exception.
This is equivalent to a \f(CWwhile {true} {\fIcmd\fP}\fR
loop except that
\f(CWforever\fP does not catch any exceptions,
including \f(CWbreak\fP.
.TP
\f(CWfork \fIcmd\fP\fR
Runs a command in a subshell.
This insulates the parent shell from the effects
of state changing operations such as \f(CWcd\fP
and variable assignments. For example:
.EX
fork {cd ..; make}
.EE
.TP
\&
runs
.MR make 1
in the parent directory (\f(CW..\fP),
but leaves the shell in the current directory.
.TP
\f(CWif \fR[\fP\fItest then\fR]\fP ... \fR[\fPelse\fR]\fP\fR
Evaluates the command \fItest\fP. If the result is true, the command
\fIthen\fP is run and \f(CWif\fP completes.
If the result of the test is false, the next \fItest-then\fP
pair is checked, until one where the \fItest\fP is true is
found. If none of the \fItest\fPs are true, the \fIelse\fP command is run.
.TP
\f(CWlimit \fR[\f(CW\-h\fR]\f(CW \fR[\fIresource \fR[\fIvalue\fR]\fR]\fR
.TQ
\f(CWlimit \f(CW\-r \fIresource
Similar to the
.MR csh 1
\f(CWlimit\fP builtin, this command operates upon the
resource limits of a process. With no arguments,
\f(CWlimit\fP prints all the current limits;
with one argument, \f(CWlimit\fP prints the named limit;
with two arguments, it sets the named limit to the given value.
The
\f(CW\-h\fP flag displays/alters the hard limits and the \f(CW\-r\fP flag will
cause limit to return the limit's value instead of printing it.
The resources which can be shown or altered are platform dependent.
For
example:
.EX
limit coredumpsize 0
.EE
.TP
\&
disables core dumps.
.TP
\&
The limit values must either be the word \(lq\f(CWunlimited\fP\(rq
or a number with an optional suffix indicating units. For size limits, the suffixes
\f(CWk\fP (kilobytes),
\f(CWm\fP (megabytes), and
\f(CWg\fP (gigabytes) are recognized.
For time limits,
\f(CWs\fP (seconds),
\f(CWm\fP (minutes), and
\f(CWh\fP (hours) are known;
in addition, times of the form
\f(CW\fIhh\fP:\fImm\fP:\fIss\fP\fR and
\f(CW\fImm\fP:\fIss\fP\fR are accepted.
See
.MR getrlimit 2
for details on resource limit semantics.
.TP
\f(CWnewpgrp\fP
Puts
.I es
into a new process group.
This builtin is useful for making
.I es
behave like a job-control shell in a hostile environment.
One example is the NeXT Terminal program, which implicitly assumes
that each shell it forks will put itself into a new process group.
Note that the controlling tty for the process must be on standard error
(file descriptor 2) when this operation is run.
.TP
\f(CWresult \fIvalue ...\fP\fR
Returns its arguments. This is \fIes\fP's identity function.
.TP
\f(CWreturn \fIvalue\fP\fR
Causes the current function to exit, returning the named
\fIvalue\fP.
.TP
\f(CWthrow \fIexception arg ...\fP\fR
Raise the named exception, passing all of the arguments to
\f(CWthrow\fP to the enclosing exception handler.
.TP
\f(CWtime \fR[\f(CW\-r\fR] \fIcmd arg ... \fP\fR
Prints, on the shell's standard error, the real, user, and system time consumed by
executing the command. The flag \f(CW\-r\fP will instead cause time to return the
status and real, user, and system times in a list.
.TP
\f(CWtrue\fP
Always returns a true (zero) return value.
.TP
\f(CWumask \fI\fR[\fPmask\fR]\fR
Sets the current umask (see
.MR umask 2 )
to the octal \fImask\fP. If no argument is present, the current mask value is printed.
.TP
\f(CWunwind-protect \fIbody cleanup\fP\fR
Runs \fIbody\fP and, when it completes or raises an exception,
runs \fIcleanup\fP.
.TP
\f(CWvar \fIvar ...\fP\fR
Prints definitions of the named variables,
suitable for being used as input to the shell.
.TP
\f(CWvars \fR[\fP\-a \||\| \-vfsgcOepiA\fR]\fP \fR[\fP-S \fIglob\fP \fR]\fP\fR
Prints all shell variables, functions, settor, and gettor functions
(in a form suitable for use as shell input),
which match the criteria specified by the options.
.IS
.TP
\f(CW\-a\fP
all objects and modifiers
.TP
\f(CW\-S glob\fP
filter objects by glob (must be quoted)
.TP
\f(CW\-n\fP
names only
.TP
\f(CW\-F\fP
format names if appropriate
.TP
\f(CW\-v\fP
print variables
.TP
\f(CW\-f\fP
print functions
.TP
\f(CW\-s\fP
print settors
.TP
\f(CW\-g\fP
print gettors
.TP
\f(CW\-c\fP
print config vars
.TP
\f(CW\-O\fP
print all types of objects
.TP
\f(CW\-e\fP
print exported values
.TP
\f(CW\-p\fP
print private values
.TP
\f(CW\-i\fP
print internal values
.TP
\f(CW\-A\fP
print all values
.TP
\f(CW\-v\fP
variables (that are not functions or settor functions)
.IE
.TP
\&
If no options are specified the defaults are \f(CWvars -ve\fP.
.TP
\f(CWwait \fI\fR[\fPpid\fR]\fR
Waits for the specified \fIpid\fP, which must have been started by
\fIes\fP. If no \fIpid\fP is specified, waits for any
child process to exit. If no pid or pid 0 is given \f(CWwait\fP returns
the waited pid and it's status code. If a specific pid is given \f(CWwait\fP
just returns the status code.
.TP
\f(CWwaitfor \fIpids ...\fR
Waits for the specified \fIpids\fP returning a list of their status
codes in the same order as the list given. If no pids are given \f(CWwaitfor\fP
waits for no processes.
.TP
\f(CWwhatis \fIprogram ...\fP
For each named \fIprogram\fP,
prints the pathname, primitive, lambda, or code fragment which
would be run if the program appeared as the first word of a command.
.TP
\f(CWwhile \fItest body \fR[\fIelse\fR]\fR
Evaluates the \fItest\fP and, if it is true, runs the
\fIbody\fP and repeats. If \fItest\fP was never true the \fIelse\fP
is executed. \fIelse\fP will never execute if the \fIbody\fP executes.
.TP
\f(CW%read\fP
Reads from standard input and returns either the empty list (in the
case of end-of-file) or a single element string with up to one line of
data, including possible redirections.  This function reads one
character at a time in order to not read more data out of a pipe than
it should.  The terminating newline (if present) is not included in
the returned string.
.SS "Hook Functions"
A subset of the
\f(CW%\fP-named
functions are known as \(lqhook functions.\(rq
The hook functions are called to implement some internal
shell operations, and are available as functions in order
that their values can be changed.
Typically, a call to a hook function is from code generated by
the syntactic sugar rewritings.
.TP
\f(CW%and \fIcmd ...\fP\fR
Runs the commands in order, stopping after the first one
that has a false return value.
Returns the result of the last command run.
.TP
\f(CW%append \fIfd file cmd\fP\fR
Runs the command with file descriptor
.I fd
set up to append to the \fIfile\fP.
.TP
\f(CW%background \fIcmd\fP\fR
Runs the command in the background. The shell variable \f(CWapid\fP
contains the process ID of the background process,
which is printed if the shell is interactive (according to \f(CW%is-interactive\fP).
.TP
\f(CW%backquote \fIseparator cmd\fP\fR
Runs the command in a child process and returns its standard output as a
list, separated (with the same rules used in \f(CW%split\fP) into elements
according to \fIseparator\fP.
.TP
\f(CW%batch-loop\fP\fR
Parses commands from the current input source and passes the commands to
the function \fI%dispatch\fP, which is usually a dynamically bound
identifier. This function catches the exception \f(CWeof\fP which causes
it to return. This function is invoked by the shell on startup and from the
dot (\f(CW.\fP) and \f(CWeval\fP commands, when the input source is not
interactive. (See also \f(CW%interactive-loop\fP.)
.TP
\f(CW%close \fIfd cmd\fP\fR
Runs the command with the given file descriptor closed.
.TP
\f(CW%count \fIlist\fP\fR
Returns the number of arguments to the primitive.
.TP
\f(CW%create \fIfd file cmd\fP\fR
Runs the command with file descriptor \fIfd\fP set up to write to
the \fIfile\fP.
.TP
\f(CW%dup \fInewfd oldfd cmd\fP\fR
Runs the command with the file descriptor
\fIoldfd\fP copied (via
.MR dup 2 )
to file descriptor \fInewfd\fP.
.TP
\f(CW%eval-noprint \fIcmd\fP\fR
Run the command.
(Passed as the argument to \f(CW%batch-loop\fP and \f(CW%interactive-loop\fP .)
.TP
\f(CW%eval-print \fIcmd\fP\fR
Print and run the command.
(Passed as the argument to \f(CW%batch-loop\fP
and \f(CW%interactive-loop\fP when the \f(CW\-x\fP
option is used.)
.TP
\f(CW%exec-failure \fIfile argv0 args ...\fP\fR
This function, if it exists, is called in the context of a
child process if an executable file was found but
.MR execve 2
could not run it. If the function returns, an error message
is printed and the shell exits, but the function can
\f(CWexec\fP a program if it thinks it knows what to do.
Note that the name of the program appears twice in the
arguments to \f(CW%exec-failure\fP,
once as a filename and once as the first element of the
\f(CWargv\fP array; in some cases the two will be identical, but in
others the former will be a full pathname and the latter
will just be the basename.Some versions of
.I es
may provide a builtin version of this function to handle
\f(CW#!\fP-style shell scripts if the kernel does not.
.TP
\f(CW%exit-on-false \fIcmd\fP\fR
Runs the command, and exits if any command
(except those executing as the tests of conditional statements)
returns a non-zero status.
(This function is used as an argument to \f(CW%batch-loop\fP
and \f(CW%interactive-loop\fP
when the shell is invoked with the \f(CW\-e\fP option.)
.TP
\f(CW%flatten \fIseparator list\fP\fR
Concatenate the elements of \fIlist\fP into one string,
separated by the string \fIseparator\fP.
.TP
\f(CW%here \fIfd word ... cmd\fP\fR
Runs the command with the \fIword\fPs passed as input on file
descriptor \f(CWfd\fP.
.TP
\f(CW%home \fR[\fIuser\fR]\fR
Returns the home directory of the named user, or \f(CW$home\fP if
there are no arguments.
.TP
\f(CW%interactive-loop\fP
Prompts, parses commands from the current input source and
passes the commands to the function \fI%dispatch\fP, which
is usually a dynamically bound identifier. This function
catches the exception \f(CWeof\fP which causes it to return.
This function is invoked by the shell on startup and from the
dot (\f(CW.\fP) commands, when the input source is interactive.
(See also \f(CW%batch-loop\fP.)
.TP
\f(CW%noeval-noprint \fIcmd\fP\fR
Do nothing. (Passed as the argument to \f(CW%batch-loop\fP
and \f(CW%interactive-loop\fP when the \f(CW\-rn\fP
option is used.)
.TP
\f(CW%noeval-print \fIcmd\fP\fR
Print but don't run the command. (Passed as the argument to
\f(CW%batch-loop\fP and \f(CW%interactive-loop\fP when
the \f(CW\-x\fP and \f(CW\-n\fP options are used.)
.TP
\f(CW%not \fIcmd\fP\fR
Runs the command and returns false if its exit status was true,
otherwise returns true.
.TP
\f(CW%one \fIlist\fP\fR
If \fIlist\fP is one element long, \f(CW%one\fP returns its value;
otherwise it raises an exception. \f(CW%one\fP is used to ensure
that redirection operations get passed exactly one filename.
.TP
\f(CW%open \fIfd file cmd\fP\fR
Runs the command with \fIfile\fP open for reading on file descriptor
\fIfd\fP.
.TP
\f(CW%open-append \fIfd file cmd\fP\fR
Runs the command with \fIfile\fP open for reading and appending
on file descriptor \fIfd\fP.
.TP
\f(CW%open-create \fIfd file cmd\fP\fR
Runs the command with \fIfile\fP open for reading and writing on
file descriptor \fIfd\fP. If the file already exists, it is truncated.
.TP
\f(CW%open-write \fIfd file cmd\fP\fR
Runs the command with \fIfile\fP open for reading and writing on file
descriptor \fIfd\fP.
.TP
\f(CW%openfile \fImode fd file cmd\fP\fR
Runs the command with \fIfile\fP opened according to \fImode\fP
on file descriptor \fIfd\fP. The
modes (\f(CWr\fP, \f(CWw\fP, \f(CWa\fP, \f(CWr+\fP, \f(CWw+\fP, and
\f(CWa+\fP) have the same meanings in \f(CW%openfile\fP as they do in
.MR fopen 3 .
\f(CW%openfile\fP is invoked by the redirection hook functions:
\f(CW%append\fP, \f(CW%create\fP, \f(CW%open\fP, \f(CW%open-append\fP,
\f(CW%open-create\fP, and \f(CW%open-write\fP.
.TP
\f(CW%or \fIcmd ...\fP\fR
Runs the commands in order, stopping after the first one that has a
true return value. Returns the result of the last command run.
.TP
\f(CW%parse \fIprompt1 prompt2\fP\fR
Reads input from the current input source, printing
\fIprompt1\fP before reading anything and
\fIprompt2\fP before reading continued lines.
Returns a code fragment suitable for execution.
Raises the exception \f(CWeof\fP on end of input.
.TP
\f(CW%pathsearch \fIprogram\fP\fR
Looks for an executable file named \fIprogram\fP in the directories
listed in \f(CW$path\fP. If such a file is found, it is returned;
if one is not found, an \f(CWerror\fP exception is raised.
.TP
\f(CW%pipe \fIcmd \fP\fR[\fP\fIoutfd infd cmd\fR] ...\fR
Runs the commands, with the file descriptor \fIoutfd\fP in the
left-hand process connected by a pipe to the file descriptor \fIinfd\fP
in the right-hand process. If there are more than two commands,
a multi-stage pipeline is created.
.TP
\f(CW%prompt\fR
Called by \f(CW%interactive-loop\fP before every call to \f(CW%parse\fI.
This function allows the user to provide any actions that he or she may
wish to have executed before being prompted (e.g., updating the value of the
\f(CWprompt\fP variable to contain all or part of the current working directory).
.TP
\f(CW%readfrom \fIvar input cmd\fP\fR
Runs \fIcmd\fP with the variable \fIvar\fP locally bound
to the name of a file which contains the output of running
the command \fIinput\fP.
.TP
\f(CW%seq \fIcmd ...\fP\fR
Runs the commands, in order.
.TP
\f(CW%whatis \fIprogram ...\fP\fR
For each named \fIprogram\fP, returns the pathname, primitive, lambda,
or code fragment which would be run if the program appeared as the
first word of a command.
.TP
\f(CW%writeto \fIvar output cmd\fP\fR
Runs \fIcmd\fP with the variable \fIvar\fP locally bound to the name of a
file which is used as the input for the command \fIoutput\fP.
.SS "Utility Functions"
These functions are useful for people customizing the shell,
may be used by other builtin commands,
and probably don't make much sense to replace,
though that is always possible.
.TP
\f(CW%add-history \fIstrings ...\fP\fR
Add strings to the command history
.TP
\f(CW%apids \fR[\fP-ad\fR]\fP\fR
Returns the process IDs of all background processes that the shell
has not yet waited for. \f(CW-a\fP returns only the alive processes and
\f(CW-d\fP returns only the dead processes.
.TP
\f(CW%fsplit \fIseparator \fR[\fIargs ...\fR]\fR
Splits its arguments into separate strings at every occurrence
of any of the characters in the string \fIseparator\fP.
Repeated instances of separator characters cause null strings to
appear in the result. (This function is used by some builtin settor functions.)
.TP
\f(CW%is-interactive\fR
Returns true if the current interpreter context is interactive;
that is, if shell command input is currently coming from an
interactive user.
More precisely, this is true if the innermost enclosing read-eval-print
loop is \f(CW%interactive-loop\fP rather than \f(CW%batch-loop\fP.
.TP
\f(CW%newfd\fP
Returns a file descriptor that the shell thinks is not currently in use.
.TP
\f(CW%run \fIprogram argv0 args ...\fP\fR
Run the named program, which is not searched for in \f(CW$path\fP, with
the argument vector set to the remaining arguments. This builtin can be
used to set \f(CWargv[0]\fP (by convention, the name of the program)
to something other than file name.
.TP
\f(CW%split \fIseparator \fR[\fPargs ...\fR]\fR
Splits its arguments into separate strings at every occurrence of any of
the characters in the string \fIseparator\fP. Repeated instances of separator
characters are coalesced. Backquote substitution splits with the same rules.
.TP
\f(CW%var \fIvar ...\fP\fR
For each named variable, returns a string which, if interpreted by \fIes\fP
would assign to the variable its current value.
.SH PRIMITIVES
Primitives exist in \fIes\fP so that, in the presence of spoofing and redefinitions,
there is a way to refer to built-in behaviors. This ability is necessary for the
shell to be able to unambiguously refer to itself, but is also useful for users
who have otherwise made their environment unnecessary but don't want to kill
the current shell.
.PP
Primitives are referenced with the
.EX
\f(CW$&\fIname\fR
.EE
.PP
notation. In this section, the \(lq\f(CW$&\fP\(rq prefixes will be omitted when
primitive names are mentioned. Note that, by convention, primitive names follow
C identifier names where \fIes\fP variable and function names often
contain \(lq\f(CW%\fP\(rq and \(lq\f(CW-\fP\(rq characters.
.PP
The following primitives directly implement the
builtin functions with the same names:
.ta 1.75i 3.5i
.EX
.ft \*(Cf
access	forever	throw
catch	fork	umask
echo	if	wait
exec	newpgrp	
exit	result	
.ft R
.EE
.PP
In addition, the primitive \f(CWdot\fP implements the \(lq\f(CW.\fP\(rq builtin
function.
.PP
The \f(CWcd\fP primitive is used in the implementation of the \f(CWcd\fP builtin,
but does not understand no arguments to imply \f(CW$home\fP. The \f(CWvars\fP
and \f(CWinternals\fP primitives are used by the implementation of the \f(CWvars\fP
builtin.
.PP
The following primitives implement the hook functions of the same names,
with \(lq\f(CW%\fP\(rq prefixes:
.ta 1.75i 3.5i
.EX
.ft \*(Cf
apids	here	read
close	home	run
count	newfd	seq
dup	openfile	split
flatten	parse	var
fsplit	pipe	whatis
.ft R
.EE
.PP
The following primitives implement the similar named hook functions,
with \(lq\f(CW%\fP\(rq prefixes and internal hyphens:
.ta 1.75i 3.5i
.EX
.ft \*(Cf
batchloop	exitonfalse	isinteractive
.ft R
.EE
.PP
The \f(CWbackground\fP primitive is used to implement the \f(CW%background\fP
hook function, but does not print the process ID of the background process or
set \f(CW$apid\fP. The \f(CWbackquote\fP primitive is used to implement the
\f(CW%backquote\fP hook function, but returns the exit status of the child as
the first value of its result instead of setting \f(CW$bqstatus\fP to it.
.PP
The following primitives implement the similarly named settor functions:
.ta 1.75i 3.5i
.EX
.ft \*(Cf
sethistory	setnoexport	setsignals
.ft R
.EE
.PP
Some primitives are included in \fIes\fP conditionally, based on compile-time
configuration options. Those primitives, and the functions to which they are
bound, are
.ta 2i
.EX
.ft \*(Cf
execfailure	%exec-failure
limit	limit
readfrom	%readfrom
time	time
writeto	%writeto
.ft R
.EE
.PP
The primitive \f(CWresetterminal\fP is vestigal. It is used in the
implementation of settor functions of the \f(CWTERM\fP and \f(CWTERMCAP\fP
variables to notify the line editing packages that the terminal configuration
has changed.
.PP
Several primitives are not directly associated with other functions.
They are:
.TQ
\f(CW$&gc\fP
.TP
\f(CW$&collect\fP
Invokes the garbage collector. The garbage collector in \f(CWes\fP
runs rather frequently; there should be no reason for a user to issue this command.
.TP
\f(CW$&noreturn \fIlambda args ...\fP\fR
Call the \fIlambda\fP, but in such a way that it does not catch the
\f(CWreturn\fP exception. This primitive exists in order that some control-flow
operations in \fIes\fP (e.g., \f(CWwhile\fP and \f(CW&&\fP) can be implemented as
lambdas rather than primitives.
.TP
\f(CW$&primitives\fP
Returns a list of the names of es primitives.
.TP
\f(CW$&buildstring\fP
Returns the program name, compiler, version, build user and host, build location,
platform, and architecture of \fIes\fP. Used to populate \f(CW$buildstring\fP.
.TP
\f(CW$&version\fP
Returns the current version number for \fIes\fP. Used to populate \f(CW$version\fP.
.SH OPTIONS
.TP
\f(CW\-c\fP
Run the given \fIcommand\fP, placing the rest of the arguments to \fIes\fP in \f(CW$*\fP.
.TP
\f(CW\-s\fP
Read commands from standard input; i.e., put the first argument to
\fIes\fP in \f(CW$*\fP rather than using it as the name of a file to source.
.TP
\f(CW\-I \fIfile\fR
Use \fIfile\fP as the initialization file instead of \f(CWinit.es\fP
or \f(CW$home/.esrc\fP.
.TP
\f(CW\-A \fIfile\fR
Run \fIfile\fP after initialization but before calling \f(CW%interactive-loop\fP
or \f(CW%batch-loop\fP.
.TP
\f(CW\-l\fR
Convince \fIes\fP that is is a login shell.
.TP
\f(CW\-N\fR
Do not run any initialization files.
.TP
\f(CW\-p\fR
Do not load any functions from the environment.
.TP
\f(CW\-o\fR
Do not open \f(CWstdin\fP, \f(CWstdout\fP, and \f(CWstderr\fP if they are closed.
.TP
\f(CW-d\fR
Do not ignore \f(CWSIGQUIT\fP and \f(CWSIGTERM\fP.
.TP
\f(CW-X \fIextended option\fR
Extended Options. These can be repeated as many times as desired.
.IS
.TP
\f(CW\-X help\fR
Display the available extended options with short summaries.
.TP
\f(CW\-X gc:\fR[\f(CWold\fR\||\|\f(CWnew\fR\||\|\f(CWgenerational\fR]\fR
Which garbage collector to use. \f(CWold\fR is default, and \f(CWnew\fP and \f(CWgenerational\fP are
experimental.
.TP
\f(CW\-X debug:\fIfile\fR
Output debugging messages to \fIfile\fP.
.TP
\f(CW\-X arenadebug:\fR[\f(CWtrue\fR\||\|\f(CWfalse\fR]\fR
Whether to enable arena allocator debugging features (if available).
.TP
\f(CW\-X protect:\fR[\f(CWtrue\fR\||\|\f(CWfalse\fR]\fR
(Old GC) Invalidate old pages (catches use after frees)
.TP
\f(CW\-X minspace:\fImegabytes\fR
(Old GC) The GC will allocate no less than \fImegabytes\fP.
.TP
\f(CW\-X gcafter:\fIn\fR
(New GC) Try to collect after \fIn\fP allocations.
.TP
\f(CW\-X sortafter:\fIn\fR
(New GC) Try to sort after \fIn\fP collections.
.TP
\f(CW\-X blocksize:\fImegabytes\fP\fR
(New GC) The allocator will allocate blocks no less than \fImegabytes\fP in size.
.TP
\f(CW\-X reserveblocks:\fIn\fR
(New GC) Allocate \fIn\fP blocks on start up.
.TP
\f(CW\-X oldage:\fIn\fR
(Generational GC) How many collections before a block is considered old.
.TP
\f(CW\-X oldsweep:\fIn\fR
(Generational GC) How many collections between old list collections.
.TP
\f(CW\-X sorting:\fR[\f(CWlist\fR\||\|\f(CWarray\fP\||\|\f(CWarraysz\fP]\fR
(New/Generational GC) Which sorting function to use.
.IE
.TP
\f(CW\-v\fR
Print $buildstring.
.TP
\f(CW\-D \fR[\f(CWGIaEPRAMrhHCtm\fR]\fR
Debugging Flags.
.IS
.TP
\f(CW?\fP
Show help message.
.TP
\f(CWG\fP
Verbose GC. This will cause the GC to output debugging information over stderr during collections
and some implementation will also output during allocations.
.TP
\f(CWI\fP
Informational GC. This will output GC statistics after collections on stderr.
.TP
\f(CWa\fP
Assertions. Enable assertions above and beyond the default.
.TP
\f(CWE\fP
Exceptions debugging.
.TP
\f(CWP\fP
Verbose Parser. This will output parser state as \fIes\fP parses the input data.
.TP
\f(CWR\fP
Regex Debugging.
.TP
\f(CWA\fP
GC Reference Counting Assertions. This enables an assertion after GC objects get dereferenced to
ensure the reference count never goes negative. This will likely crash \fIes\fP.
.TP
\f(CWM\fP
Verbose Match. Causes \fIes\fP to output internal state during matches.
.TP
\f(CWT\fP
Have \fIes\fP attach the token causing the problem to yyparse exceptions.
.TP
\f(CWr\fP
Verbose \f(CWrangematch\fP. Part of the match debugging machinery.
.TQ
\f(CWh\fP
.TP
\f(CWH\fP
Which hash should \f(CWDict\fP use? \f(CWh\fP is the default \(lqHaahr\(rq hash and \f(CWH\fP
is the more modern FNV-1A.
.TP
\f(CWC\fP
Comprehensive \f(CWmatch\fPes. Throw an assert if a \f(CWmatch\fP fails to match. This causes
a litany of problems in \fIes\fP and the standard library. Use as your own risk.
.TP
\f(CWt\fP
Forces \fIes\fP to assume that \f(CWstdin\fP, \f(CWstdout\fP, and \f(CWstderr\fP are a TTY.
.TP
\f(CWe\fP
Forces \fIes\fP to use the fallback editor instead of the line editor.
.TP
\f(CWm\fP
Enable dynamic library debugging and informational messages.
.IE
.TP
\f(CW\-r \fR[\f(CWeinVxL\fR]\fR
Run Flags
.IS
.TP
\f(CW?\fP
Print a help summary.
.TP
\f(CWe\fP
Exit on false. Exit if any command (except those executing as tests of
conditional statements) returns a non-zero status.
.TP
\f(CWi\fP
Interactive. Force \fIes\fP into thinking it's running interactively.
.TP
\f(CWn\fP
Do not execute any commands. \fIes\fP will still parse input.
.TP
\f(CWv\fP
Print all unparsed input.
.TP
\f(CWx\fP
Print all parsed input before execution.
.TP
\f(CWL\fP
Similar to \f(CW-rx\fP but outputs using S-Expressions. (lisptrees)
.TP
\f(CWa\fP
Enable extra assertions. (same as -Da).
.IE
.SH BUGS
Lexical scope which is shared by two variables (or closures) in a parent shell
is split in child shells.
.PP
The interpreter should be properly tail recursive;
that is, tail calls should not consume stack space.
.PP
\f(CWbreak\fP and \f(CWreturn\fP should have lexical scope.
.PP
Woe betide the environment string set by some other program to
contain either the character control-o or the sequence control-n
followed by control-o or control-n.
.PP
\f(CW\-rx\fP is not nearly as useful as it should be.
.PP
Line numbers in error messages refer to the last line parsed,
rather than something more useful.
.PP
Too many creatures have fept in.
.SH "SEE ALSO"
.MR history 1 ,
.MR rc 1 ,
.MR sh 1 ,
.MR execve 2 ,
.MR getrlimit 2 ,
.MR fopen 3 ,
.MR getpwent 3 ,
.MR pcre2 3 ,
.MR pcre2pattern 3 ,
.MR pcre2syntax 3 ,
.MR re_format 7
.PP
.UR https://github.com/mveety/es
es-mveety repository
.UE
.PP
.UR https://github.com/wryun/es-shell
The mothership
.UE
.PP
Paul Haahr and Byron Rakitzis,
.I "Es \(em A shell with higher-order functions,"
Proceedings of the Winter 1993 Usenix Conference,
San Diego, CA.
.PP
Tom Duff,
.I "Rc \(em A Shell for Plan 9 and UNIX Systems,"
Unix Research System,
10th Edition,
Volume 2.
(Saunders College Publishing)
